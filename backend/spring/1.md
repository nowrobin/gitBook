# 과제-1

1\) 애플리케이션 아키텍처에서 애플리케이션 서버 티어를 구성하는 3가지 레이어 에 대해 설명하고 결합도를 줄이기 위한 방법을 설명하시오.\
&#x20;                     &#x20;

프레젠테이션 레이어:

&#x20;웹에서 진행되는 클라이언트의 요청을 처리하는 레이어이다.         HTTP을 이용해서 요청하고 해당 응답을  화면에 나오게 처리하고  인터페이스를 제어 하는 역할의 레이어이다. 사용자가 보낸 요청을 적절한 비즈니스 로직으로 넘겨서 처리하도록하고 해당 응답을 화면 인터페이스에 적절하게 처리한다. 따라서 최종적으로 UI 와 UI에 들어가는 데이터를 결정 하는 레이어로서,  비즈니스 로직과  UI를 분리시켜서 사용하고, 해당 기능을 하기위해 Controller 라는 어노테이션을 사용해서 작용하고 UI에 들어가는 데이터들을 유효성검사를 진행한다.

&#x20;

비즈니스 로직 레이어:

요구사항에 맞게 디자인된 로직들을 처리하는 레이어로서 비지니스에 관련된 핵심적인 기능들을 하는 로직들이 들어가있다. 프레젠테이션레이어 와 데이터  액세스 레이어를 연결시켜주는 다리역할을 한다.  프레젠테이션에 사용자가 직접적으로 데이터에 접근하지 못하게 막기위해 분리시켜 한다.  트랜잭션 또한 이 레이어에서 발생하는데  ACID를 적용하여, 원자성, 격리성을 위해 트랜잭션들을 관리한다.  명시적 트랜잭션으로 RDB(Relational Data Base) 에서 사용되는 커밋, 롤백을 소스코드로 명시하여 관리하는 방식과  선언적 트랜잭션으로   프레이워크에서 정의되어있는 파일을 사용해서 트랜잭션 관리한다. 비즈니스 로직은 Service 어노테이션을 사용하는데 , Controller가 Service를 통해 DAO에 필요한 데이터를 가지고는 역할이다.

&#x20;

데이터 액세스 레이어:                                                       &#x20;

해당 애플리케이션에서 사용되는 모든 데이터 저장소에 액세스하는 레이어이다. ORM을 사용하는 계층으로 (Object Relational Mapping) 으로 CRUD를 ( Create, Read, Update, Destro)를 실행한다. 비지니스 로직에서 숨겨진 RDB액세스를 DB에서 테이블를  오브젝트와 매핑 시켜서 사용하는걸 O/R 매핑이라고한다.DB 액세스로  많이 사용되는 프레임 워크들로 Hibernate 와 Mybatis가있다. 이용하는 RDB에 의존하는 SQL을 사용하면 안되고, RDB의 종류가 바뀌어도 문제없어야한다.                                                                                                                     &#x20;

2\)  스프링 프레임워크의 특징인 POJO, DI, AOP를 설명하시오.

POJO:  Plain Old Java Object

이름을 직역하면 간단한 오랜된 오브젝트이다, Old Java Object들은 특정기술에 종속되어있어 그러한 기술들을 의존하게되었다. 환경과 기술에 종속되어있지 않는 순수한 오브젝트를 POJO라 칭하며, 자유롭고 재활용이 가능한 오브젝트이다. 어딘가에 상속되어있으면 의존관계가 생겨나기때문에 문제가되서 진정한 POJO가 아니다.  Spring  프레이워크로서  라이브러리를 사용하고있기때문에 객체가 가볍고, 따로 상속받지 않기때문에 자유롭다. 따라서 POJO를 사용하고 있다고 볼수있다. 라이브러리를 사용할때는, 따로 상속개념이 아니기때문에 의존관계가 없이 override를 할필요가 없다. Spring을 POJO로 만들어 주는 기술들이 DI와 AOP이다.

&#x20;

DI:  Dependency Injection

객체간의 관계를 주입 시키기위해서, 만들어진 패턴이다. 클래스단에서 관계가 생기면 관계가 고정되어 결합도가 높아진다. 결합도가 높아지면 나중에 클래스 재활용하기가 어렵다. 이럴때 효율적으로 사용하게하는 게 DI 인데, 외부적으로  객체간의 관계를 주입시켜서 런타임시 동적으로 관계를 만들어준다. DI 컨테이너 , 또는 IOC 컨테이너 라고 불리는데, 의존관계를 관리해준다. DI를 IoC 라고하는데 역전의제어 객체(빈)을 생성부터 의존관계까지 관리를 프레임워크에있는 컨테이너가 관리하기때문,  개발자의 소스크드의 제어하는 역할이 프레임워크로 넘어갔기때문이다. DI를 사용할때  XML, Annotation, Java 방식들이 존재한다.

&#x20;

AOP: Aspect Oriented Programming

관계지향 프로그래밍으로 비즈니스 로직을 기준으로 핵심적인 관점과, 부가적인 관점을 나누어서 모듈화 시킨 방식이다.여기서 사용하는것이 프록시 패턴인데,  하나의 매소드안에 너무많은 기능들이 존재할때 응집도 문제와 테스트 및 리팩토링이 어렵기때문에  핵심기능과 부가적인 기능들을 나누어주는 패턴이다. 따라서 실제 클라이언트가  사용하는 모든 기능에 대해서는 문제 없이 사용가능하지만 기능은 나누어 지고 있기때문에 분산 처리가 가능하다. 이러한 동적으로 프록시 객체를 만들어주는것이 AOP이다. 따라서 핵심적인 기능들의 코드를 재활용하면서 부가적인 코드는 따로 빼서 다른 클래스로 만들주어 모듈할수있다

&#x20;                                          &#x20;

3\)  스프링 빈, IoC 컨테이너, ApplicationContext를 설명하시오.\
\


스프링 빈:   &#x20;

spring-bean: IOC container, 또는 DI 컨테이너에서 관리하는 객체를 말한다. new .. 으로 객체를 생성 하는것이 아닌, spring 자체적인 container를 통해서 생성된다. ApplicationContext.getBean() 매소드를 작성해서 bean(객체를 가지고 온다). 이러한 빈들은 POJO 라고도 할수있다.

Bean 설정하는 방법 :

XML: \<Bean> 태그를 사용해서 , 직접적으로 연결 시킴

Annotation: @Component 로 부여된 클래스를 자동으로 부여시키는 방법

&#x20;

IoC 컨테이너:

스프링 빈들의 생명주기 및  의존관계 설정들을 관리해주는 컨테이너를 IoC  컨테이너라고한다. IoC(Inversion of Control) 역전 제어로서,  소스코드로 빈(객체)를 제어하고 관리하는것이 아닌 프레임워크에서 생성되는 컨테이너가 책임지고 제어하기때문에 개발자가 직접 관리하는 수고를 덜어준다.

IoC컨테이너로서  Bean Factory, Application Context가 있다. Container가 관리하는  객체들인 빈을 생산하고 관리하는 공장 으로서 조회 부터 분배하는 과정까지의 역할을 한다.  BeanFactory가 빈을 로딩할때, Lazy-loading 방식을 사용하는데 빈이 사용되어야할때만 빈을 로드하여 미리 모든 빈을 생성 하는것이 아닌, 필요한 빈들만 로드해주는방식을 사용한다 .

ApplicationContext:

Bean Factory의 확장형을로 상속받아서 사용하는 컨테이너이다.  따라서 Bean Factory에서 부가적인 기능들이 추가된것이, ApplicationContext 인데, 추가된 기능들은  국제화 텍스트 기능 , 환경 변수 관련 처리 , 애플리케이션 이벤트,  리소스 조회 , 리스너 이벤트  발생여부 판단 등이 존재 하지만 ,  BeanFactoy 와 차이로는  BeanFactory는 lazy-loading으로 필요한 빈만 로드했다면, ApplicationContext 는 pre-loading  방식으로  모든 빈을 로드 해야지 사용가능하다.

&#x20;                                 &#x20;

4\) XML기반의생성자기반과설정자기반의존성주입방식의차이를코드로비 교 설명하시오.\
&#x20;                                                         &#x20;

| <p>application.xml<br>&#x3C;bean id = "memberDAO" class="org.tukorea.di.persistence.MemberDAOImpl"><br>&#x3C;/bean><br>&#x3C;bean id= "memberService" class= "org.tukorea.di.service.MemberServiceImpl"><br>생성자 기반 의존성 주입방식<br>     &#x3C;constructor-arg ref= "memberDAO"/><br>설정자 기반 의존성 주입방식<br>     &#x3C;property name= "memberDAO" ref= "memberDAO"/><br>&#x3C;/bean></p> |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
|                                                                                                                                                                                                                                                                                                                                                                                 |

&#x20;                     &#x20;

| <p>private MemberDAO membrDAO;<br>생성자 기반 의존성 주입방식<br>public MemeberServiceImple(memberDAO memberDAO){<br>설정자 기반 의존성 주입방식<br>public setMemberDAO( memberDAO memberDAO){<br>------------------------------------------------------------------------<br>      this.memberDAO = memberDAO;<br>}</p> |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |

&#x20;

5\)  ANNOTATION 설정 방법에서 \<context:annotation-config />와 \<context:component-scan base-package=“명”/> 차이점을 설명하시오.

우선 Annotation 방식은 @Component로 사용된는데 부연받은  클래스를 기반으로 빈을 설정 한다. @Autowired 를 선언하여 컨테이너와  다른 객체(빈)의 의존성을  자동으로  설정하고 연결한다. 이떄 필요한게 annotation-config 설정인데 context 파일에 bean을 등록하고 사용한다. 하지만 component-scan 을 사용하면 따로 bean을 등록할 필요없이 Autowired를 사용가능하다.  component-scan은 @Component를 선언하여 특정 패키지를 지정해주면 안에있는 빈을 스캔하여 자동으로  빈을 컨테이너에 등록을 해주기때문이다. componenet-scan을 annotation-config를 상속받고 확정된 방식이다.                                                                           &#x20;

6\)  자바를이용한DI설정방법을XML기반의생성자기반의존성주입방식과비 교하여 설명하시오.

&#x20;

XML 기반 생성자 의존성 주입:

빈을 등록하기위해,  applicationContext.xml  에 빈을 등록해야한다.  \<constructor-arg/>를 사용해야한다.  따라서 xml에서 등록되어있는 빈들을 이용하여  의존성을 주입시킨다.

| <p>&#x3C;bean id="memberDAO" class= "className"><br>&#x3C;constructor-arg ref="bean id"/><br> &#x3C;/bean></p> |
| -------------------------------------------------------------------------------------------------------------- |

&#x20;

자바 DI 설정 방법:

자바롤 DI 하는 방법은 JavaConfig 파일을 생성하여 @Configuration 어노테이션을 사용하여 빈 설정 메타 정보를 가지고있는 클래스를 선언하여  @Bean 어노테이션으로 매서드를 정의하여 빈 객체 정의한다. 따라서 bean id를 매서드 이름으로 쓰고  constructor ref 에 있는 객체를  반환되서 사용하는 매소드에 주입시키는 방식이다. 또한 name 속성을 사용하여 새로운 빈 이름을 적용할수있다.

| <p>@Bean (name="Service")<br>public memberService beanID(){<br>      return new serviceImpl(의존하는 빈의 Id)<br>}</p> |
| ---------------------------------------------------------------------------------------------------------------- |

&#x20;
